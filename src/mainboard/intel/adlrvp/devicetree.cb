chip soc/intel/alderlake

	# This disables autonomous GPIO power management, otherwise
	# old cr50 FW only supports short pulses.
	register "gpio_override_pm" = "1"
	register "gpio_pm[COMM_0]" = "0"
	register "gpio_pm[COMM_1]" = "0"
	register "gpio_pm[COMM_2]" = "0"
	register "gpio_pm[COMM_4]" = "0"
	register "gpio_pm[COMM_5]" = "0"

	# GPE configuration
	# Note that GPE events called out in ASL code rely on this
	# route. i.e. If this route changes then the affected GPE
	# offset bits also need to be changed.
	register "pmc_gpe0_dw0" = "GPP_B"
	register "pmc_gpe0_dw1" = "GPP_D"
	register "pmc_gpe0_dw2" = "GPP_E"

	# FSP configuration
#	register "EnableAzalia" = "1"
#   register "DspEnable" = "1"

	# Enable CNVi BT
	register "cnvi_bt_core" = "true"

	# Sagv Configuration
	register "sagv" = "SaGv_Enabled"

	register "usb2_ports[0]" = "USB2_PORT_MID(OC0)"		# Type-C Port1
#	register "usb2_ports[1]" = "USB2_PORT_MID(OC0)"		# Type-C Port2 Unused in vvdn
#	register "usb2_ports[2]" = "USB2_PORT_MID(OC3)"		# Type-C Port3 Unused in vvdn
	register "usb2_ports[3]" = "USB2_PORT_MID(OC_SKIP)"	# M.2 WWAN
	register "usb2_ports[4]" = "USB2_PORT_MID(OC_SKIP)" # Camera vvdn
#	register "usb2_ports[4]" = "USB2_PORT_MID(OC3)"		# Type-C Port4
	register "usb2_ports[5]" = "USB2_PORT_MID(OC_SKIP)"	# FPS connector	
	register "usb2_ports[6]" = "USB2_PORT_MID(OC0)"		# USB3/2 Type A port1
	register "usb2_ports[7]" = "USB2_PORT_MID(OC0)"		# USB3/2 Type A port2
	register "usb2_ports[8]" = "USB2_PORT_MID(OC3)"		# USB3/2 Type A port3
	register "usb2_ports[9]" = "USB2_PORT_MID(OC_SKIP)"	# M.2 WLAN

#	register "usb3_ports[0]" = "USB3_PORT_DEFAULT(OC3)"	# USB3/2 Type A port1
#	register "usb3_ports[1]" = "USB3_PORT_DEFAULT(OC0)"	# USB3/2 Type A port2
#	register "usb3_ports[2]" = "USB3_PORT_DEFAULT(OC0)"	# USB3/2 Type A port3
	register "usb3_ports[3]" = "USB3_PORT_DEFAULT(OC_SKIP)"	# M.2 WWAN

	# EC host command ranges are in 0x800-0x8ff & 0x200-0x20f
	register "gen1_dec" = "0x00fc0801"
	register "gen2_dec" = "0x000c0201"
	# EC memory map range is 0x900-0x9ff
	register "gen3_dec" = "0x00fc0901"

	# Enable PCH PCIE RP 5 using CLK 2
	register "pch_pcie_rp[PCH_RP(5)]" = "{
		.clk_src = 2,
		.clk_req = 2,
		.flags = PCIE_RP_CLK_REQ_DETECT,
	}"

	# Enable PCH PCIE RP 6 using CLK 5
	register "pch_pcie_rp[PCH_RP(6)]" = "{
		.clk_src = 5,
		.clk_req = 5,
		.flags = PCIE_RP_CLK_REQ_DETECT,
	}"
	
	# Enable PCH PCIE RP 7 using CLK 6
	register "pch_pcie_rp[PCH_RP(7)]" = "{
           .clk_src = 6,
           .clk_req = 6,
           .flags = PCIE_RP_LTR | PCIE_RP_AER,
   }"

	device ref pcie_rp7 off
#		chip drivers/net                                                    
#			register "customized_leds" = "0x05af"
#			register "wake" = "GPE0_DW0_02"     # GPD2
#	 		register "stop_gpio" = "ACPI_GPIO_OUTPUT_ACTIVE_LOW(GPP_A21)"
#	 		register "add_acpi_dma_property" = "true"
#			register "device_index" = "0"
#			device pci 00.0 on end
#		end                                                                 
   end # RTL8111H Ethernet NIC 

	# NOTE: requires GPP_A7 set to Native Function 1 for SRCCLK_OE7
	register "pch_pcie_rp[PCH_RP(8)]" = "{
                .clk_src = 7,
                .clk_req = 7,
                .flags = PCIE_RP_CLK_REQ_DETECT | PCIE_RP_LTR,
                .PcieRpL1Substates = L1_SS_L1_2,
		.pcie_rp_detect_timeout_ms = 50,
	}"

	# Enable PCH PCIE RP 9 using CLK 1
	register "pch_pcie_rp[PCH_RP(9)]" = "{
		.clk_src = 1,
		.clk_req = 1,
		.flags = PCIE_RP_CLK_REQ_DETECT,
	}"

	# Enable PCH PCIE RP 11 for optane
	register "pch_pcie_rp[PCH_RP(11)]" = "{
		.flags = PCIE_RP_CLK_SRC_UNUSED,
	}"

	# Hybrid storage mode
	register "hybrid_storage_mode" = "1"

	# Enable CPU PCIE RP 1 using CLK 0
	register "cpu_pcie_rp[CPU_RP(1)]" = "{
		.clk_req = 4,
		.clk_src = 4,
		.flags = PCIE_RP_LTR | PCIE_RP_AER,
	}"

	# Enable CPU PCIE RP 2 using CLK 3
#	register "cpu_pcie_rp[CPU_RP(2)]" = "{
#		.clk_req = 3,
#		.clk_src = 3,
#		.flags = PCIE_RP_LTR | PCIE_RP_AER,
#	}"

	# Enable CPU PCIE RP 3 using CLK 4
#	register "cpu_pcie_rp[CPU_RP(3)]" = "{
#		.clk_req = 0,

#		.clk_src = 0,
#		.flags = PCIE_RP_LTR | PCIE_RP_AER,
#	}"

	register "sata_salp_support" = "1"

	register "sata_ports_enable" = "{
		[0] = 1,
		[1] = 1,
		[2] = 1,
		[3] = 1,
	}"

	register "sata_ports_dev_slp" = "{
		[0] = 1,
		[1] = 1,
		[2] = 1,
		[3] = 1,
	}"

	# Enable EDP in PortA
	register "ddi_portA_config" = "1"
	# Enable HDMI in Port B
	register "ddi_ports_config" = "{
		[DDI_PORT_B] = DDI_ENABLE_HPD | DDI_ENABLE_DDC,
	}"

	# TCSS USB3
	register "tcss_aux_ori" = "0"

	register "s0ix_enable" = "1"
	register "dptf_enable" = "1"

	register "serial_io_i2c_mode" = "{
		[PchSerialIoIndexI2C0] = PchSerialIoPci,
		[PchSerialIoIndexI2C1] = PchSerialIoPci,
		[PchSerialIoIndexI2C2] = PchSerialIoPci,
		[PchSerialIoIndexI2C3] = PchSerialIoPci,
		[PchSerialIoIndexI2C4] = PchSerialIoDisabled,
		[PchSerialIoIndexI2C5] = PchSerialIoPci,
	}"

	register "serial_io_gspi_mode" = "{
		[PchSerialIoIndexGSPI0] = PchSerialIoPci,
		[PchSerialIoIndexGSPI1] = PchSerialIoPci,
		[PchSerialIoIndexGSPI2] = PchSerialIoDisabled,
		[PchSerialIoIndexGSPI3] = PchSerialIoDisabled,
	}"

	register "serial_io_gspi_cs_mode" = "{
		[PchSerialIoIndexGSPI0] = 1,
		[PchSerialIoIndexGSPI1] = 1,
		[PchSerialIoIndexGSPI2] = 0,
		[PchSerialIoIndexGSPI3] = 0,
	}"

	register "serial_io_gspi_cs_state" = "{
		[PchSerialIoIndexGSPI0] = 1,
		[PchSerialIoIndexGSPI1] = 1,
		[PchSerialIoIndexGSPI2] = 0,
		[PchSerialIoIndexGSPI3] = 0,
	}"

	register "serial_io_uart_mode" = "{
		[PchSerialIoIndexUART0] = PchSerialIoSkipInit,
		[PchSerialIoIndexUART1] = PchSerialIoDisabled,
		[PchSerialIoIndexUART2] = PchSerialIoDisabled,
	}"

	# HD Audio
#	register "pch_hda_dsp_enable" = "1"
#	register "pch_hda_sdi_enable[0]" = "1" #vvdn
#	register "pch_hda_sdi_enable[1]" = "1" #vvdn
#	register "pch_hda_audio_link_hda_enable" = "1"  #vvdn
	
#	register "PchHdaAudioLinkDmicEnable[0]" = "1"
#	register "PchHdaAudioLinkDmicEnable[1]" = "1"

#	register "pch_hda_audio_link_dmic_enable[0]" = "1"  #vvdn
#	register "pch_hda_audio_link_dmic_enable[1]" = "1"  #vvdn
#	register "pch_hda_audio_link_sndw_enable[0]" = "1"  #vvdn
#   register "pch_hda_audio_link_sndw_enable[1]" = "1"  #vvdn
	
#	register "pch_hda_idisp_link_tmode" = "HDA_TMODE_8T"
#	register "pch_hda_idisp_link_frequency" = "HDA_LINKFREQ_96MHZ"
#	register "pch_hda_idisp_codec_enable" = "1"
	
	register "cnvi_bt_audio_offload" = "true"

	# Intel Common SoC Config
	register "common_soc_config" = "{
		.gspi[0] = {                                                            
            .speed_mhz = 1,                                                     
			.early_init = 1,                                                    
         },  
		.gspi[1] = {
			 .speed_mhz = 1,
			 .early_init = 1,
        },
		.i2c[0] = {
			.speed = I2C_SPEED_FAST,
		},
		.i2c[1] = {
			.speed = I2C_SPEED_FAST,
		},
		.i2c[2] = {
			.speed = I2C_SPEED_FAST,
		},
		.i2c[3] = {
			.speed = I2C_SPEED_FAST,
		},
		.i2c[5] = {
			.speed = I2C_SPEED_FAST,
		},
	}"

	device domain 0 on
		device ref pcie5_0 on end
		device ref igpu on end
		device ref dtt on
			chip drivers/intel/dptf

				## sensor information
				register "options.tsr[0].desc" = ""Ambient""
				register "options.tsr[1].desc" = ""Battery""
				register "options.tsr[2].desc" = ""DDR""
				register "options.tsr[3].desc" = ""Skin""

				## Active Policy
				# TODO: below values are initial reference values only
				register "policies.active" = "{
					[0] = {
							.target = DPTF_CPU,
							.thresholds = {
								TEMP_PCT(95, 90),
								TEMP_PCT(90, 80),
							}
						},
					[1] = {
							.target = DPTF_TEMP_SENSOR_0,
							.thresholds = {
								TEMP_PCT(80, 90),
								TEMP_PCT(70, 80),
							}
						}
				}"

				## Passive Policy
				# TODO: below values are initial reference values only
				register "policies.passive" = "{
					[0] = DPTF_PASSIVE(CPU,		CPU,	       95, 10000),
					[1] = DPTF_PASSIVE(CPU,		TEMP_SENSOR_0, 85, 50000),
					[2] = DPTF_PASSIVE(CHARGER,	TEMP_SENSOR_1, 85, 50000),
					[3] = DPTF_PASSIVE(CPU,		TEMP_SENSOR_2, 85, 50000),
					[4] = DPTF_PASSIVE(CPU,		TEMP_SENSOR_3, 85, 50000),
				}"

				## Critical Policy
				# TODO: below values are initial reference values only
				register "policies.critical" = "{
					[0] = DPTF_CRITICAL(CPU,	  105, SHUTDOWN),
					[1] = DPTF_CRITICAL(TEMP_SENSOR_0, 95, SHUTDOWN),
					[2] = DPTF_CRITICAL(TEMP_SENSOR_1, 95, SHUTDOWN),
					[3] = DPTF_CRITICAL(TEMP_SENSOR_2, 95, SHUTDOWN),
					[4] = DPTF_CRITICAL(TEMP_SENSOR_3, 95, SHUTDOWN),
				}"

				## Power Limits Control
				register "controls.power_limits" = "{
					.pl1 = {
							.min_power = 35000,
							.max_power = 45000,
							.time_window_min = 28 * MSECS_PER_SEC,
							.time_window_max = 32 * MSECS_PER_SEC,
							.granularity = 200,
					},
					.pl2 = {
							.min_power = 56000,
							.max_power = 56000,
							.time_window_min = 28 * MSECS_PER_SEC,
							.time_window_max = 32 * MSECS_PER_SEC,
							.granularity = 1000,
					}
				}"

				## Charger Performance Control (Control, mA)
				register "controls.charger_perf" = "{
					[0] = { 255, 3000 },
					[1] = {  24, 1500 },
					[2] = {  16, 1000 },
					[3] = {   8,  500 }
				}"

				## Fan Performance Control (Percent, Speed, Noise, Power)
				register "controls.fan_perf" = "{
					[0] = {  90, 6700, 220, 2200, },
					[1] = {  80, 5800, 180, 1800, },
					[2] = {  70, 5000, 145, 1450, },
					[3] = {  60, 4900, 115, 1150, },
					[4] = {  50, 3838,  90,  900, },
					[5] = {  40, 2904,  55,  550, },
					[6] = {  30, 2337,  30,  300, },
					[7] = {  20, 1608,  15,  150, },
					[8] = {  10,  800,  10,  100, },
					[9] = {   0,    0,   0,   50, }
				}"

				## Fan options
				register "options.fan.fine_grained_control" = "1"	# 0 is another option
				register "options.fan.step_size" = "2"				# 0 is another option

				device generic 0 alias dptf_policy on end
			end
		end
		
		#Removed MIPI Camera

		device ref pcie4_0 on end
		device ref pcie4_1 on end
		device ref tbt_pcie_rp0 on end
		device ref tbt_pcie_rp1 on end
		device ref tbt_pcie_rp2 on end
		device ref tbt_pcie_rp3 on end
		device ref crashlog off end
		device ref tcss_xhci on end
		device ref tcss_dma0 on end
		device ref tcss_dma1 on end
		device ref xhci on
			chip drivers/usb/acpi
				register "desc" = ""Root Hub""
				register "type" = "UPC_TYPE_HUB"
				device ref xhci_root_hub on
					chip drivers/usb/acpi
                        register "desc" = ""USB2 Camera""
                        register "type" = "UPC_TYPE_INTERNAL"
						device ref usb2_port5 on end
					end
					chip drivers/usb/acpi
						register "desc" = ""Bluetooth""
						register "type" = "UPC_TYPE_INTERNAL"
						device ref usb2_port10 on end
					end
				end
			end
		end
		device ref cnvi_wifi on
			chip drivers/wifi/generic
				register "wake" = "GPE0_PME_B0"
				device generic 0 on end
			end
		end

		device ref i2c0 on
			chip drivers/i2c/hid
				register "generic.hid" = ""PNP0C50""
				register "generic.desc" = ""ELAN Touchpad""
				register "generic.irq_gpio" = "ACPI_GPIO_IRQ_LEVEL_LOW(GPP_E12)"
				register "generic.detect" = "1"
				register "hid_desc_reg_offset" = "0x20"
				device i2c 15 on end
			end
		end

		device ref i2c1 off end #Removed MIPI Camera
		device ref i2c2 off end
		device ref i2c3 off end
		device ref heci1 on end
		device ref sata off end
		device ref i2c5 off end #Removed MIPI Camera

		device ref pcie_rp5 on
#			chip drivers/wifi/generic
#				register "wake" = "GPE0_DW1_13" #GPP_D13
#				device pci 00.0 on end
#			end
		end
		device ref pcie_rp1 off end
		device ref pcie_rp6 off end
		device ref pcie_rp8 off end
		device ref pcie_rp9 off end
		device ref pcie_rp11 off end
		device ref uart0 on end
		device ref gspi0 off end
		device ref gspi1 on end
		device ref pch_espi on end   
		device ref p2sb on end

		device ref fast_spi on		# Fast SPI TPM
			chip drivers/spi/acpi
				register "hid" = "ACPI_DT_NAMESPACE_HID"
				register "compat_string" = ""infineon,SLB9670""
				register "irq" = "ACPI_IRQ_LEVEL_LOW(GPP_E3_IRQ)"
				device spi 0 on end
			end
		end

		device ref hda off end
		device ref smbus on end
   end
end
